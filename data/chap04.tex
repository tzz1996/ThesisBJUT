%
% 第四章
%
\chapter{基于UEFI的硬盘文件安全加载策略实现}
\label{cha:detail_design}
UEFI环境中硬盘文件的安全加载依赖于UEFI固件系统中对UEFI各个启动阶段核心代码的可信验证，和对特定文件
系统协议栈驱动程序和硬盘ESP分区中文件的可信测量，本文在第三章中已经描述了此安全方案在基于原有UEFI BIOS
的基础上进行的阶段设计和可信度量模块的设计。在本章将会针对第三章中的设计方案提出对应的具体实施过程，其中
包括可信度量模块各个模块的具体实现和根据各个启动阶段的特点进行的启动阶段安全方案实现。

%
% 4.1节
%
\section{可信度量驱动的实现}
此安全方案设计的DXE阶段可信度量驱动程序属于DXE服务型驱动，其中包含了几个主要的功能模块，他们分别是
第三章中系统结构图提出的可信度量值计算模块、固件文件系统和硬盘文件系统访问模块、BMC通信模块、驱动程序
度量模块和硬盘文件度量模块，本节将对这些模块做更细致的介绍和实现细节。

\subsection{可信度量值计算模块}
可信度量值计算模块是对自定义SHA1散列函数的封装，用于对DXE阶段的四个UEFI文件系统协议栈驱动程序进行完整性
度量，并对BDS core进行度量；也负责在BDS阶段对硬盘文件数据进行可信测量。
\par 此度量过程采用SHA1散列值计算方法，SHA1是由NISTNSA设计为同DSA一起使用的，它对长度小于2的64次方的输入，
产生长度为160bit的散列值，因此抗穷举(brute-force)性更好。SHA-1设计时基于和MD4相同原理,并且模仿了该算法。
SHA-1是由美国标准技术局（NIST）颁布的国家标准，是一种应用最为广泛的hash函数算法，也是目前最先进的加密
技术，被政府部门和私营业主用来处理敏感的信息。而SHA-1基于MD5，MD5又基于MD4。

\begin{lstlisting}
typedef struct{
    EFI_SHA1_INIT SHA_Init;
    EFI_SHA1_UPDATE SHA_Update;
    EFI_SHA1_FINAL SHA_Final;
    EFI_SHA1_CLEAN SHA_Clean；
} EFI_SHA1_PROTOCOL;
\end{lstlisting}

代码列出的是自定义的EFI\_SHA1\_PROTOCOL协议，用于在加载DXE阶段的可信度量驱动时通过Openprotocol的启动时
服务的系统调用加载到UEFI系统的句柄数据库中。其中EFI\_SHA1\_INIT，EFI\_SHA1\_UPDATE，EFI\_SHA1\_FINAL，
EFI\_SHA1\_CLEAN为四个函数指针，用于指向位于驱动中的函数实现。SHA\_Init函数指针所指向的函数用于初始化一个
用于SHA1算法加密过程的数据结构SHA\_CTX，该结构存放弄了生成SHA1散列值的一些参数。SHA\_Update函数用于处理
大文件，将其分散成等份的较小值，并对每一块分别调用SHA\_Update生成对应的散列值。SHA\_Final函数用于将
SHA\_Update函数生成的分块的散列值通过运算形成一个最终的160bits的散列值。SHA\_Clean函数用于清除SHA\_CTX
数据结构中针对SHA1算法初始化的数据。

\begin{lstlisting}
typedef struct SHAstate_st {
    SHA_LONG h0,h1,h2,h3,h4;
    SHA_LONG Nl,Nh;
    SHA_LONG data[SHA_LBLOCK];
    unsigned int num;
} SHA_CTX;
\end{lstlisting}

在结构体SHA\_CTX中，SHA\_LONG定义为unsigned int类型，SHA-1采用160位的信息摘要，也以32位为计算长度，
就需要5个链接变量，因此h0-h4用来在SHA\_Init过程中初始化并存储这5个链接变量用于度量过程中的计算。其中
的SHA\_LBLOCK变量的扩展值为64，意味着SHA1在进行分组运算时，每一组的长度为512bits及64Bytes。

%
% 4.2节
%
\subsection{固件文件系统访问模块}
固件文件系统访问模块用于给可信度量值计算模块提供各个阶段的核心代码和DXE阶段的文件系统协议栈驱动程序在FV
固件卷中的数据信息。需要根据FV固件卷中FFS固件文件系统的数据格式提取出对应的核心或驱动文件的Image信息。
但FV固件卷中存储的FFS格式的文件中并不只包含着可运行的EFI类型二进制文件，还有着许多标识着文件类型、文件
修改信息等众多段信息，若要对UEFI各个阶段核心代码和特定驱动文件进行度量，必须确定需要度量的EFI可执行文件
的data部分内容，以确保基准值的计算与UEFI启动过程中度量值的计算所计算的EFI数据内容统一。
\par 本节将详细说明FFS文件的存储格式以及此安全方案的固件文件系统访问模块如何进行的设计与实现。

\subsubsection{FFS文件存储格式}
根据第二章中所述的FV固件卷数据存储方式的介绍可知，FV固件中的文件以section的形式分段存储，每个数据段存储
特定的文件规格信息。但要在UEFI内存中精确的获取到核心和驱动程序文件的EFI数据内容，就需要更详细的FFS文件
存储格式研究。FV固件卷中文件的存储方式表示在图4-1中。

\begin{figure}[htb]
    \label{ffs_format}
    % 调整图片与上文的垂直距离 %
    \vspace{0cm}   
    % 调整图片图片与中文标题、中文标题与英文标题距离 %
    \setlength{\abovecaptionskip}{0.3cm}
    % 引用/fig/目录中的图片文件 %
	\centering
    \includegraphics[width=12cm]{fv_format.png}
    % 中文标题 %
    \caption*{图 4-1 固件卷数据存储格式}
    % 调整图片英文标题与下文距离(本文标准为-0.7cm) %
    \setlength{\belowcaptionskip}{-0.7cm}
    % 英文标题 %
    \caption*{Figure 4-1 The Firmware Volume Format}
\end{figure}

如图4-1所示，符合PI规范的FV固件卷文件包含主要两部分，其中一部分是如图所示的firmware volume header
固件卷头部，另一部分是firmware volume data固件卷数据部分。其中固件卷头部用于描述此FV文件的所有属性信息，
同时也包含了一个用来标识组织固件中数据存储格式的固件文件系统的UEFI全局标识符GUID。固件卷头部不仅可以支持
UEFI特定的FFS固件文件系统，还支持一切符合PI规范的固件文件系统。
\par 当UEFI系统加载FV中的文件信息时，首先识别固件卷头部，并用名为EFI\_FIRMWARE\_VOLUME\_HEADER的
数据结构用来在UEFI内存中存储头部信息。固件卷数据部分也用GUID的形式在内存中进行唯一标识，其中UEFI规范
认可的固件文件系统GUID用EFI\_FIRMWARE\_FILE\_SYSTEM2\_GUID和EFI\_FIRMWARE\_FILE\_SYSTEM3\_GUID写死在BIOS
的固件芯片中。当单个文件内容小于16MB时，系统将采用EFI\_FIRMWARE\_FILE\_SYSTEM2\_GUID来描述固件文件
系统，若单个文件内容大于16MB，并且向后兼容SYSTEM2类型的FFS时，将采用EFI\_FIRMWARE\_FILE\_SYSTEM3\_GUID
来描述。

\begin{figure}[htb]
    \label{ffs_format}
    % 调整图片与上文的垂直距离 %
    \vspace{0cm}   
    % 调整图片图片与中文标题、中文标题与英文标题距离 %
    \setlength{\abovecaptionskip}{0.3cm}
    % 引用/fig/目录中的图片文件 %
	\centering
    \includegraphics[width=10cm]{ffs_file_layout.png}
    % 中文标题 %
    \caption*{图 4-2 固件文件系统文件布局}
    % 调整图片英文标题与下文距离(本文标准为-0.7cm) %
    \setlength{\belowcaptionskip}{-0.7cm}
    % 英文标题 %
    \caption*{Figure 4-2 Typical FFS File Layout}
\end{figure}

\par 如图4-1所示，固件卷中每一个文件以单独的结构进行存储，文件名称为FFS file。一个文件中包含了文
件头部，用于记录文件中section内容及文件属性的信息，如图4-2中所示的文件状态、文件大小、文件名称、文件属性、
文件类型等信息，图4-2展示的是一个ffs文件的文件结构组成，其中所有的头部和数据信息都是32位对齐的。
同时包含了一组section。每一个section中也都分别包含一个section头部信息，还有section中的数据内容。
UEFI规范所规定的固件文件系统section分类及信息如表4-1。

\begin{table}[htb]
    \label{tab:parametervalues}
    % 设置表内行间距 %
    \renewcommand\arraystretch{1.5}
    % 设置表题目 %
	\caption*{表 4-1 固件文件系统分段信息}
	\caption*{Table 4-1 The Firmware File System Section Imformation}
    \begin{tabular*}{\hsize}{@{}@{\extracolsep{\fill}}ccl@{}}
    % 表上线和表头 %
	\toprule[0.75pt]
    名称  &数值  &\makecell[c]{描述}\\
    % 表中线和表内容 %
	\midrule[0.5pt]
	EFI\_SECTION\_COMPRESSION     &0x01  &\quad 封装了其他被压缩的分段\\
    EFI\_SECTION\_GUID\_DEFINED   &0x02  &\makecell[l]{
                                          \quad 封装部分，其中其他部分的格式由GUID\\
                                                定义\\
                                        }\\
    EFI\_SECTION\_DISPOSABLE      &0x03  &\makecell[l]{
                                          \quad 在构建过程中使用的封装部分，但执行时\\
                                                不需要\\
                                        }\\
    EFI\_SECTION\_PE32            &0x10  &\quad PE32格式信息和可执行映像\\
    EFI\_SECTION\_PIC             &0x11  &\quad 位置无关的代码段\\
    EFI\_SECTION\_DXE\_DEPEX      &0x13  &\quad DXE阶段依赖表达式\\
    EFI\_SECTION\_VERSION         &0x14  &\quad 版本号，文字和数字信息\\
    EFI\_SECTION\_RAW             &0x19  &\quad raw数据信息\\
    EFI\_SECTION\_PEI\_DEPEX      &0x1b  &\quad PEI阶段依赖表达式\\
    % 表下线 %
	\bottomrule[0.75pt]
    \end{tabular*}
    % 表格与下文距离 %
    \vspace{-0.3cm}
\end{table}

如表4-1所示，在FV固件卷中的每个section中，都对应着不同的section分类信息，其中可以看到，EFI\_SECTION\_PE32
这个section中存放着DXE驱动程序相关的关键信息，其中包含了PE32格式的说明信息，还有就是对应的EFI可执行文件，
也就是驱动程序真正的可执行代码部分内容。在此安全方案的可信度量模块中，度量的就是UEFI启动各个阶段核心代码和
驱动程序代码在FV固件卷中对应这个section里的相关信息。从表4-1中还可以看出，如EFI\_SECTION\_GUID\_DEFINED
段的信息内容可以在FV固件卷中标识驱动程序的GUID信息，这也为在UEFI启动阶段在加载驱动程序时，通过内存中的驱动
GUID和FV固件中的GUID匹配做好了实现基础。在众多section中，同样包括了如EFI\_SECTION\_VERSION这样的驱动文件
版本的文字和数字信息标识。
\par 表4-1中的EFI\_SECTION\_DXE\_DEPEX和EFI\_SECTION\_PEI\_DEPEX段的信息内容同样是两个关键的段信息，
他们分别用于表达DXE阶段和PEI阶段对应的各个驱动程序和PEIM的加载顺序，此安全方案的实现需要借助这两个驱动依赖
关系的字段来确定关键驱动加载的顺序问题，具体的依赖表达式关系及实施将在后面的小结中详细说明。

\subsubsection{固件文件访问模块实现}
在确定了FFS固件文件系统数据存储的具体格式之后，将在此可信度量驱动中的固件文件系统访问模块中实现UEFI内存中
的驱动文件加载方法和内存中的存储方式。此模块将调用Boot Service启动服务中的LoadImage（）系统函数，在UEFI
中，所有系统服务中存储的都是具体函数的函数指针，因此真正的映像加载功能函数由CoreLoadImage（）函数负责实现，
并且其他系统函数也遵循这样的命名规则。具体函数的调用过程可通过代码分析得知，为CoreLoadImage调用
CoreLoadImageCommon再最终通过CoreLoadPeImage函数进行PE32格式的文件数据加载。而这个格式也就对应上面提到
的FV中的EFI\_SECTION\_PE32段里的内容。

\begin{lstlisting}
EFI_STATUS
CoreLoadPeImage (
    IN BOOLEAN                     BootPolicy,
    IN VOID                        *Pe32Handle,
    IN LOADED_IMAGE_PRIVATE_DATA   *Image,
    IN EFI_PHYSICAL_ADDRESS        DstBuffer    OPTIONAL,
    OUT EFI_PHYSICAL_ADDRESS       *EntryPoint  OPTIONAL,
    IN  UINT32                     Attribute
)
\end{lstlisting}

如上面CoreLoadPeImage函数定义的代码段，CoreLoadPeImage函数中BootPolicy输入参数如果为TRUE，则表示请求
来自引导管理器，并且引导管理器正尝试加载FilePath作为引导选择。Pe32Handle输入参数指定了加载到UEFI内存中
的PE32格式的映像句柄。Image参数为LOADED\_IMAGE\_PRIVATE\_DATA格式的数据结构，用于在系统内存中表示此DXE
驱动程序的详细信息，其中也包含了PE32文件格式的头部信息和data数据信息。DstBuffer参数为可选输入参数，用于
指定将此驱动文件映像存储至调用者指定的内存buffer缓存中。EntryPoint参数同样为可选参数，用于指定PE32 section
中EFI可执行文件的入口点。Attribute为32位的image属性信息参数，每一bit位分别用于表示image信息。
\par 其中IN和OUT为通过C语言\#define宏定义定义的空类型名称，用于给编码人员确定函数的输入和输出参数的设定，
UEFI实现中函数统一采用这种方式，符合UEFI规范。

\begin{lstlisting}
typedef struct {
    EFI_HANDLE                  Handle;   
    UINTN                       Type;           
    BOOLEAN                     Started;        
    EFI_IMAGE_ENTRY_POINT       EntryPoint;     
    EFI_LOADED_IMAGE_PROTOCOL   Info;           
    EFI_PHYSICAL_ADDRESS        ImageBasePage;  
    UINTN                       NumberOfPages;  
    CHAR8                       *FixupData;              
    EFI_STATUS                  Status;         
    UINTN                       ExitDataSize;   
    VOID                        *ExitData;      
    VOID                        *JumpBuffer;    
    BASE_LIBRARY_JUMP_BUFFER    *JumpContext;  
    UINT16                      Machine;     
    ...         
    EFI_RUNTIME_IMAGE_ENTRY     *RuntimeData;   
    EFI_DEVICE_PATH_PROTOCOL    *LoadedImageDevicePath;  
    PE_COFF_LOADER_IMAGE_CONTEXT  ImageContext; 
    EFI_STATUS                  LoadImageStatus;
} LOADED_IMAGE_PRIVATE_DATA;
\end{lstlisting}

如上面代码所示，LOADED\_IMAGE\_PRIVATE\_DATA数据结构用于在UEFI内存中表示DXE驱动程序的完整信息，其中
Handle和EntryPoint和CoreLoadPeImage函数的参数保持一致。ImageBasePage和NumberOfPages字段用于描述此
驱动文件在内存中所占以页为单位的起始页位置和所占页数。也包括了用32位存储的驱动类型信息，其中UEFI中支持的
驱动映像类型包括：

\begin{lstlisting}
#define EFI_IMAGE_SUBSYSTEM_EFI_APPLICATION 10
#define EFI_IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER 11
#define EFI_IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER 12
\end{lstlisting}

他们分别表示UEFI上层应用型映像文件，启动时服务的驱动映像文件和运行时驱动映像文件，并且PE32格式的映像类型
属于EFI\_IMAGE\_SUBSYSTEM\_EFI\_RUNTIME\_DRIVER类型，可在加载驱动映像时进行类型的判别。
\par LOADED\_IMAGE\_PRIVATE\_DATA数据结构中的ImageContext关键字段为可信度量过程的主要依据，ImageContext
是一个PE\_COFF\_LOADER\_IMAGE\_CONTEXT类型结构体，用来记录驱动文件加载信息。

\begin{lstlisting}
typedef struct {
    ......
    VOID              *ImageBase;
    UINT64            ImageSize;
    ......
} PE_COFF_LOADER_IMAGE_CONTEXT;
\end{lstlisting}

其中ImageBase就是记录内存中PE32格式文件的起始地址，ImageSize提供了文件的大小，通过把PE32格式驱动映像
文件加载到指定地址，并将其记录在这两个变量中，就可以在度量时获取到驱动文件内容。

%
% 4.3节
%
\subsection{硬盘文件系统访问模块}
硬盘文件系统访问模块提供FAT文件系统中ESP分区内系统文件数据的加载过程，此模块由BDS core代码调用，用来
将指定硬盘文件数据加载到UEFI内存中，过程如下所示。

\begin{lstlisting}
EFI_STATUS
LoadFileInEsp(
    IN EFI_HANDLE                             Handle,
    OUT UINTN                                 DesAddr;
) {
    EFI_FILE                        *RootIo;
    EFI_FILE                        *FileIo;
    EFI_SIMPLE_FILE_SYSTEM_PROTOCOL *VolumeInterface;
    CHAR16                          *imgdir=L"\\boot\\test_file.efi";
    Status = gBS->HandleProtocol (
        Handle,
        &gEfiSimpleFileSystemProtocolGuid,
        (VOID **) &VolumeInterface
    );
    Status = VolumeInterface->OpenVolume(VolumeInterface, &RootIo);
    Status = RootIo->Open(RootIo, &FileIo,imgdir,EFI_FILE_MODE_READ, EFI_FILE_READ_ONLY);
    Status = FileIo->Read(FileIo, &Size, (VOID *)DesAddr);
...
}
\end{lstlisting}

如代码清单所示，首先需要通过Boot Service的HandleProtocol服务来加载系统提供的
EFI\_SIMPLE\_FILE\_SYSTEM\_PROTOCOL文件系统协议，将其安装在提供的Handle句柄上。然后调用协议中的OpenVolume
打开FV固件卷文件，将信息挂载到RootIo这个EFI\_FILE结构中，这个结构对应的是UEFI文件系统协议栈里的FileIo协议。
然后就是通过提供的具体文件相对路径，通过EFI\_FILE\_READ\_ONLY文件只读模式将其打开到FileIo，并通过文件协议
中的Read方法读取文件内容到指定地址。

\subsection{驱动文件度量模块}
驱动文件度量模块是此安全方案的核心内容，因为此模块需要负责对UEFI文件系统协议栈的四个驱动程序进行可信度量，
以确保他们的内容不被非法篡改。在有了固件文件系统访问模块的基础上，已经可以获取到FV固件中的驱动文件内容，
而度量模块，需要对加载到UEFI内存中的驱动文件内容进行信息匹配，以确保进行特定驱动程序的度量工作。因此需要
根据UEFI规范，确定四个驱动程序的GUID内容，以进行匹配。

\begin{lstlisting}
[Defines]
    BASE_NAME       = DiskIoDxe
    FILE_GUID       = 6B38F7B4-AD98-40e9-9093-ACA2B5A253C4
    ...
[Defines]
    BASE_NAME       = PartitionDxe
    FILE_GUID       = 1FA1F39E-FEFF-4aae-BD7B-38A070A3B609
    ...
[Defines]
    BASE_NAME       = AtaAtapiPassThruDxe
    FILE_GUID       = 5E523CB4-D397-4986-87BD-A6DD8B22F455
    ...
[Defines]
    BASE_NAME       = FatFileSys
    FILE_GUID       = a6a0274b-78da-4b77-8fb2-9c355a2e7f6a
    ...
\end{lstlisting}

如上面代码清单所示，四个UEFI文件系统协议栈驱动的GUID分别标注在了四个驱动INF模块文件的[Defines]字段中。
在确定了GUID后，就需要在度量功能的代码中进行GUID的匹配，再进行驱动数据内容的度量。需要说明的是，在四个
驱动程序中，由于UEFI使用的GPT分区格式和各个硬件设计为统一格式，因此PartitionDxe和DiskIoDxe驱动在各个
真机平台上是统一的；而PassThruDxe和FileSys驱动需要根据不同的物理平台确定不同的驱动和特定GUID。这里采用
的是申威6A型号服务器的具体驱动名称和GUID信息。

\begin{lstlisting}
EFI_STATUS
DriverMeasurement(
    IN LOADED_IMAGE_PRIVATE_DATA   *Image
) {
    switch (Image->ImageContext.ImageType) {
    ...
    case EFI_IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER:
        if (CompareGuid(Image->ImageContext->Name, DiskIoDxeName) ||
            CompareGuid(Image->ImageContext->Name, PartitionDxeName) ||
            CompareGuid(Image->ImageContext->Name, AtaAtapiPassThruDxeName) ||
            CompareGuid(Image->ImageContext->Name, FatFileSysName))
                BmcCheck(Image->ImageContext);
    ...
}
\end{lstlisting}

驱动度量函数首先根据传进来的内存中的驱动数据结构表示，判别驱动类型，由于四个文件系统协议栈驱动都属于
EFI\_IMAGE\_SUBSYSTEM\_EFI\_RUNTIME\_DRIVER类型，因此可以通过这个条件进行初步判断。在确定驱动类型正确
之后，进行GUID的判别，其中的四个特定驱动程序GUID通过INF文件获取的方式写死在代码中。若确定此正在加载的驱动
是四个驱动之一，则通过可信度量值计算模块中的SHA1计算协议进行度量，并通过GUID在BMC中获取到相应的基准值，
这些功能都通过BmcCheck函数实现。
\par 其中的CompareGuid函数用于比较128位的GUID值，通过把128位的GUID数据结构通过强制类型转换
(CONST UINT64*) Guid转换为UEFI系统中可以直接通过==符号进行比较的UINT64数据类型的指针，指针中包含了两个
元素，分别是GUID的高64位和底64位，然后通过表达式
(LowPartOfGuid1 == LowPartOfGuid2 \&\& HighPartOfGuid1 == HighPartOfGuid2)来返回比较结果的BOOLEAN
类型值。
\par 在驱动度量模块中，另一个重要的功能就是生成度量日志的功能。此功能的目的是向BMC系统发送UEFI启动过程
中度量UEFI文件系统协议栈的四个驱动和特定硬盘ESP分区文件时，将度量过程中产生的hash值和BMC中取出的基准值，
以及度量结果通过日志写入的方式，存储于BMC系统固件中。由于此功能不需要UEFI系统和BMC系统尽心数据互送，只
需要UEFI系统单向得将ASCII码信息写入BMC系统，因此通信方式没有采用IPMI协议，而是通过IO端口映射的方式，将
数据流写入目的地址。

\begin{lstlisting}
UINTN
EFIAPI
SerialPortWrite (
    IN UINT8     *Buffer,
    IN UINT32     Size
    )
{
    PRINTCONFIG* Pconfig;
    UINT8 cpuid;
    cpuid = hard_smp_processor_id ();
    cpuid = cpuid & (CORENUM_PER_CG - 1);
    Pconfig = PRINTK_BUF_CONFIG;
    Pconfig += cpuid;
    ...
    CopyMem (Pconfig->Start + Pconfig->Index, Buffer, Size);
    Pconfig->Index += Size;
    ...
}
\end{lstlisting}
上述代码描述的是度量日志写入功能中向串口写入信息的函数。其中输入参数Buffer是使用系统调用AsciiVSPrint函数
后，通过DEBUG信息生成的ASCII码格式的字符串，用8位的无符号整数的指针表示，其中每8位正好对应一个ASCII码，
表示一个英文字符。PRINTCONFIG是一个用来在内存中表示打印信息参数的数据结构，用于记录每次Buffer需要写入的
目的地址，其中Start字段是PRINTCONFIG在内存中的起始地址，Index字段用于在每次写入以此Buffer数据后，自加一
以达到下次调用串口写入函数时，写入到上次数据内容的后面。PRINTCONFIG的地址是通过计算得到的，PRINTK\_BUF\_CONFIG
是一个系统写死的数值，内容为0xfffffc0000870000UL，用于记录PRINTCONFIG结构在IO映射地址的位置，此内容是
在系统DXE阶段初始化过程中确定的。hard\_smp\_processor\_id是一段汇编代码用于计算cpuid。值得注意的是，
这个串口写入函数是处理器体系结构相关的，因为PRINTCONFIG结构在计算地址时用到了cpuid值，并且在系统初始化时
PRINTK\_BUF\_CONFIG值的内容也是根据具体物理真机系统的自定义而决定的。
\par 硬盘文件度量模块的逻辑与驱动度量模块相似，需要通过文件名来调用BMC通信模块，获取到BMC芯片中存储的文件
基准值信息，并在内存中通过SHA1算出加载前的度量值，进行比较得到度量结果。

\subsection{BMC通信模块}
BMC通信模块是图3-13中所示的，在此安全方案中，属于DXE阶段和BDS阶段所使用的与BMC系统通信的功能模块。由于
DXE和BDS阶段共同使用的是DXE阶段初始化的Boot Service和Runtime Service，因此保证了BMC通信模块中系统调用
的统一性。由于需要通过BMC通信模块获取基准值，因此不光需要向BMC发送数据，还需要BMC处理并返回对应的结果，
因此借助于IPMI协议来实现。

\begin{lstlisting}
struct _EFI_IPMI_INTERFACE_PROTOCOL {
    EFI_IPMI_INTERFACE_SEND_COMMAND       SendCommand;
    EFI_IPMI_INTERFACE_RECEIVE_PACKET     ReceivePacket;
    EFI_IPMI_INTERFACE_GET_STATUS         GetStatus;
};
\end{lstlisting}
如上面的代码清单所描述，DXE阶段的BMC通信模块定义了一个名为EFI\_IPMI\_INTERFACE\_PROTOCOL的IPMI通信协议
结构体，其中包含了三个主要的函数指针。SendCommand函数用于通过UEFI系统向BMC系统发送IPMI格式的命令代码，
ReceivePacket函数用于在UEFI系统中读取BMC系统写入特定硬件缓存并通过UEFI的IO端口映射到内存中的地址，
GetStatus函数则用于读取特定的BMC寄存器，并按位解析BMC状态信息。
\par BMC通信模块以DxeInitlizeIpmiKcs作为入口函数，加载对应的IPMI协议中三个主要功能函数到Protocol数据
结构中，并通过gBS->InstallMultipleProtocolInterfaces，Boot Service中的安装协议函数通过
gEfiIpmiInterfaceProtocolGuid协议的全局标识信息，安装于EFI\_IPMI\_INSTANCE结构的Handle字段中。

\subsubsection{发送数据过程}

\begin{lstlisting}
EFI_STATUS
EFIAPI
IpmiSendCommand (
    IN  EFI_IPMI_INTERFACE_PROTOCOL    *This,
    IN  UINT8                          Command,
    IN  UINT8                          *CommandData,
    IN  UINT8                          CommandDataSize
) {
    ...
    Status = KcsWaitforIbfClear(Instance);
    WriteKcsCommand(Instance,KCS_WRITE_START);
    Status = KcsCheckStatus(Instance,&KcsStatus);
    if(KcsStatus.Bits.State !=KcsWriteState){
    return KcsErrorExit(Instance);
    }
    KcsClearObf(Instance);
    for(i=0; i<DataSize-1; i++) {
        WriteKcsData(Instance,Data[i]);
        Status = KcsCheckStatus(Instance,&KcsStatus);
        if(EFI_ERROR(Status)) {
            return EFI_DEVICE_ERROR;
        }
        if(KcsStatus.Bits.State !=KcsWriteState){
            return KcsErrorExit(Instance);
        }
        KcsClearObf(Instance);
    }
    WriteKcsCommand(Instance,KCS_WRITE_END);
    Status = KcsCheckStatus(Instance,&KcsStatus);
    if(KcsStatus.Bits.State !=KcsWriteState){
        return KcsErrorExit(Instance);
    }
    KcsClearObf(Instance);
    WriteKcsCommand(Instance,Data[i]);
    ...
}
\end{lstlisting}
如上代码所示，通过解析发送命令函数来说明与BMC系统的通信方式。发送函数接收主要的8位标识的命令信息，和命令
数据大小，然后根据IPMI协议提供的KCS数据发送状态流，依次设置KCS命令和查询相关寄存器，配合数据接收寄存器的
数据写入过程。代码的写入流程如图4-3。

\begin{figure}[htb]
    \label{ffs_format}
    % 调整图片与上文的垂直距离 %
    \vspace{0cm}   
    % 调整图片图片与中文标题、中文标题与英文标题距离 %
    \setlength{\abovecaptionskip}{0.3cm}
    % 引用/fig/目录中的图片文件 %
	\centering
    \includegraphics[width=14cm]{kcs_write_transfer.png}
    % 中文标题 %
    \caption*{图 4-3 kcs模式数据写入流程}
    % 调整图片英文标题与下文距离(本文标准为-0.7cm) %
    \setlength{\belowcaptionskip}{-0.7cm}
    % 英文标题 %
    \caption*{Figure 4-3 KCS Write Transfer Flow}
\end{figure}

如图4-3所示，是IPMI协议的KCS访问模式中数据写入BMC的执行流程，其中一共涉及到4种BMC寄存器的访问与操作，他们
包括Data\_In\_R、Data\_Out\_R、Status\_R和Command\_R，其中Status\_R是查询BMC状态的寄存器，Data\_Out\_R
和Data\_In\_R负责给BMC和外界系统如BIOS，提供数据的读出和写入缓存，用寄存器的方式来实现。Command\_R寄存器
用来表示输入BMC系统的命令。
\par 在图4-3中，首先等待Status\_R寄存器中的IBF标志位为0，表示此时没有数据输入到Data\_In\_R中。然后通过
将WRITE\_START命令写入Command\_R寄存器，将BMC状态改变为wr\_start写入开始状态。随后通过查询Status\_R中的值，
等待IBF标志位为0，表示BMC收到了WRITE\_START命令并判别有效；同时通过8位的状态寄存器获取到的值确认BMC此时的
状态确实改变为了WRITE\_STATE。后面就进入了数据写入的循环中，由于KCS模式是按字节传输数据，因此为Command\_R
寄存器设置两个命令分别为WRITE\_START和WRITE\_END来确定传入缓冲寄存器中的第一个和最后一个字节为单位的数据包。
每写入一个字节的数据之后，都要通过Status\_R检查IBF位，确定数据输入是否有效，同时检查BMC是否还保持WRITE\_STATE
状态。当根据数据size判断下一个字节是最后一个传输字节时，退出写入循环，并向Command\_R写入WRITE\_END命令，
来通知BMC下一个字节是最后一个。写入最后一个字节的流程和前面循环中的写入流程一致。最后BMC的状态转换成了read，
表示等待外部系统读取Data\_Out\_R中的返回值。

\begin{table}[htb]
    \label{tab:parametervalues}
    % 设置表内行间距 %
    \renewcommand\arraystretch{1.5}
    % 设置表题目 %
	\caption*{表 4-2 BMC状态寄存器标志位说明}
	\caption*{Table 4-2 KCS Interface Status Register Bits}
    \begin{tabular*}{\hsize}{@{}@{\extracolsep{\fill}}ccl@{}}
    % 表上线和表头 %
	\toprule[0.75pt]
    比特位  &名称  &\makecell[c]{描述}\\
    % 表中线和表内容 %
    \midrule[0.5pt]
    0                             &OBF       &\quad 输出数据有效标志位\\
    1                             &IBF       &\quad 输入数据有效标志位\\
    2                             &SMS\_ATN  &\quad 表明BMC有事务需要软件系统处理\\
    3                             &C\_D\_n   &\makecell[l]{
                                              \quad 表明最后写入的是Command\_R还是\\
                                                    Data\_In\_R，“1”表示 Command\_R\\
                                            }\\
    5：4                          &OEM       &\quad 保留标志位\\
    7：6                          &S1:S0     &\quad KCS读写状态机状态\\
    % 表下线 %
	\bottomrule[0.75pt]
    \end{tabular*}
    % 表格与下文距离 %
    \vspace{-0.3cm}
\end{table}

如表4-2所示，其中7：6也就是bit7和bit6形成一个四种情况的状态组合，有限状态机组合情况如下：
\par 00：IDLE\_STATE，表示KCS接口是空闲的，外部系统不应预期收到或向其发送任何数据。
\par 01：READ\_STATE，读状态表示BMC正在向外部系统传输一个一字节大小的数据包，此时外部系统也应处于对应的
读取信息状态。
\par 10：WRITE\_STATE，写状态表示BMC正在从外部系统接收一个数据包，此时外部系统需要向BMC写入一个命令。
\par 11：ERROR\_STATE，表示BMC在接口级别检测到协议违规，或者传输已中止。外部系统可以使用Get\_Status
控制代码来请求错误的性质，也可以仅重新执行该命令。下面将介绍UEFI BIOS从BMC获取返回值的流程。

\subsubsection{接收数据过程}
KCS访问模式下外部系统读取BMC数据过程，所使用到的寄存器信息与发送过程一致。如图4-4所示，由于在外部系统写入
数据到BMC后，BMC状态机转换位等待读取的状态，因此首先检查IBF标志位保证上一次输入BMC的数据有效后，检查状态
是否为READ\_STATE，此状态为读取BMC数据的循环判断状态。当状态有效时，在OBF为1，保证输出有效的情况下，读取
DATA\_OUT中的一字节数据，随后再向DATA\_IN中写入READ，通过外部系统将BMC设置为READ\_STATE，然后进入读取循环。
直到读取完最后一个字节后，并由外部系统写READ指令后，BMC改变自身状态为IDLE\_STATE，以此来退出读取循环，并
写入输出缓存一个dummy字节。外部系统读取dummy字节后，完成整个读取操作。

\begin{figure}[htb]
    \label{ffs_format}
    % 调整图片与上文的垂直距离 %
    \vspace{0cm}   
    % 调整图片图片与中文标题、中文标题与英文标题距离 %
    \setlength{\abovecaptionskip}{0.3cm}
    % 引用/fig/目录中的图片文件 %
	\centering
    \includegraphics[width=10.6cm]{kcs_read_transfer.png}
    % 中文标题 %
    \caption*{图 4-4 kcs模式数据读取流程}
    % 调整图片英文标题与下文距离(本文标准为-0.7cm) %
    \setlength{\belowcaptionskip}{-0.7cm}
    % 英文标题 %
    \caption*{Figure 4-4 KCS Read Transfer Flow}
\end{figure}

%
% 4.4节
%
\section{UEFI启动阶段补充说明}

\subsection{SEC阶段设计}
由于SEC阶段是此可信链中的信任根，因此SEC阶段的数据内容安全可信，又因为SEC阶段占有很少的系统资源，仅有很小的
临时内存，因此不涉及BMC的交互功能，将SEC阶段度量PEI core的基准值信息，也就是PEI core的SHA1散列值，和临时的
SHA1算法，集成在SEC core的代码中，以此来完成阶段度量的任务。SEC阶段的BMC日志信息的输出由于不借助IPMI协议，
因此不需要BMC驱动程序，只需调用上述BMC串口写入函数，即可将日志信息写入BMC芯片中。

\subsection{PEI阶段设计}

\subsection{DXE阶段驱动依赖关系}

%
% 4.5节
%
\section{本章小结}


